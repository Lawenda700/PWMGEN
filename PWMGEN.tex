\documentclass{article}
\usepackage{graphicx} 
\title{Documentație PWMGEN}
\author{Brăduț-Mihai Iordache(Lawenda700)\\ Eduard Simion(eddy-24)\\Mario Timoc(MarioTimoc21)} 

\renewcommand{\contentsname}{Cuprins}
\begin{document}
\maketitle
\newpage
\tableofcontents
\pagestyle{myheadings}
\markright{Brăduț-Mihai Iordache(Lawenda700), Eduard Simion(eddy-24), Mario Timoc(MarioTimoc21)}
\newpage
\section{SPI BRIDGE}
Modulul SPI bridge folosește 2 blocuri \texttt{always}, unul pentru frontul crescător al ceasului 
și celălalt pentru frontul descrescător. Ambele verifică activarea funcției de reset și, în caz că aceasta este activată, resetează valorile output-urilor la valorile default + valoarea celor 2 countere interne. Pe frontul crescător (blocul \texttt{always posedge}) avem citirea în MOSI. Se citește de la MSB la LSB valoarea din \texttt{data\_out} cu ajutorul unui counter care este decrementat de la 7 până la 0, iar odată ce se citește valoarea de la bitul 0 al \texttt{data\_out}, counter-ul se resetează.\\
\\
În mod similar, pe frontul descrescător (blocul \texttt{always negedge}) se scrie în registrul intermediar \texttt{data\_int} de la MSB la LSB valorile primite din MISO, cu ajutorul unui counter intern care funcționează identic cu cel utilizat pentru citirea în MOSI pe posedge. Atunci când counter-ul pentru MISO atinge valoarea 0 și se resetează, se trimite și informația din \texttt{data\_int} în \texttt{data\_in} și se setează valoarea lui \texttt{byte\_sync} la 1 (ea fiind default 0) pentru a semnala trimiterea unui nou \texttt{data\_in} către instruction decoder. \\
\\
Citirea și scrierea se realizează doar atunci când chip select-ul \texttt{cs\_n}  este setat (are valoarea 0). Când nu este setat, citirea și scrierea nu se realizează, iar valoarea counterelor interne este în permanență ținută la 7 (poziția MSB).







\newpage
\section{INSTRUCTION DECODER}
Instruction Decoder-ul funcționează asemenea unui AFD cu 3 stări. Trecerea dintr-o stare în alta se realizează pe frontul crescător al ceasului, iar în caz de reset se revine în starea S0. Stările automatului: \\
\\
S0: Se verifică primirea semnalului \texttt{byte\_sync} care semnalează primirea datelor de input. Se scrie în \texttt{data\_write} pe poziția 0 valoarea bitului de pe poziția 6 din \texttt{data\_write} (ne ajută la scrierea în MSB/LSB din registri), se preia valoarea bitului de pe poziția 7 și, în caz că este 1, \texttt{write} este setat ca 1 și se trece în starea S1 a automatului, iar în caz că este 0, \texttt{read} este setat ca 1 și se trece în starea S2 a automatului. Totodată, biții [5:0] din \texttt{data\_in} sunt scriși în \texttt{addr}.  
În caz că \texttt{byte\_sync} este 0, nu se întâmplă nimic.\\
\\
S1: Se verifică primirea semnalului \texttt{byte\_sync} care semnalează primirea datelor de input.
Datele din \texttt{data\_in} sunt transferate în totalitate în \texttt{data\_write} și se trece în starea S0 a automatului.\\
\\
În caz că \texttt{byte\_sync} este 0, nu se întâmplă nimic.\\
\\
S2: Se trec datele din \texttt{data\_out} în \texttt{data\_read} și se trece în starea S0 a automatului.


\newpage
\section{REGISTERS}
Se stochează adresele registrelor pe 6 biți în parametrii locali ai modulului. Se declară un registru \texttt{sb} care va indica dacă scrierea/citirea se va face în MSB sau în LSB pentru registrele care sunt pe 16 biți. Funcționarea modulului va avea forma unui AFD cu 3 stări (S3, S4, S5). La activarea funcției de reset toți registrii sunt trecuți în valoarea default și se revine la starea S3. Trecerea dintr-o stare în alta se realizează pe frontul crescător al ceasului. Stările automatului: \\
\\
S3: \texttt{sb} ia valoarea bitului 0 din \texttt{data\_write}. Dacă \texttt{write} este 1 se trece la starea S4, alternativ se trece la S5.\\
\\
S4: \texttt{counter\_reset} revine la valoarea 0 (acesta trebuie, conform documentației, să fie 1 doar un singur ciclu de ceas după ce este setat). Se verifică, cu un bloc \texttt{case}, adresa la care trebuie scrisă informația din \texttt{data\_write} și implicit registrul. Dacă registrul este pe 16 biți, se verifică \texttt{sb} pentru a vedea dacă \texttt{data\_write} se scrie în MSB sau LSB. Se trece în starea S3.\\
\\
S5: Se verifică, cu un bloc \texttt{case}, adresa la care se află registrul care trebuie citit în \texttt{data\_read} (dacă adresa nu este una în care se află unul dintre registre, se citește valoarea 0). Dacă registrul este pe 16 biți, se verifică \texttt{sb} pentru a vedea dacă \texttt{data\_read} se citește din MSB sau LSB. Se trece în starea S3.



\newpage
\section{COUNTER}
Se creează un counter intern și un \textit{period} intern (numit \texttt{ss}), care este un \texttt{wire} setat ca 1 pe 16 biți, shiftat la stânga cu \texttt{prescale} număr de biți. Se declară un bloc \texttt{always} activ pe frontul crescător al ceasului, care, la activarea funcției de reset, resetează \texttt{count\_val} la valoarea default (0 pentru \texttt{upnotdown = 1} și \texttt{period} pentru \texttt{upnotdown = 0}) și valoarea counter-ului intern la 0. De menționat că registrul care dă valoarea lui \texttt{count\_val} este cu 1 mai mare decât valoarea lui \texttt{count\_val}, pentru a ține cont de faptul că numărătoarea începe de la 0. Numărătoarea începe atunci când \texttt{en} are valoarea 1.\\
\\
Când \texttt{upnotdown} este 1, numărătoarea este crescătoare de la 0 la \texttt{period - 1}, iar când este 0, este descrescătoare de la \texttt{period - 1} la 0.\\
\\
Incrementarea/Decrementarea lui \texttt{count\_value} se realizează atunci când counter-ul intern ajunge la valoarea \texttt{ss - 1} (deoarece începe de la 0). Când se incrementează/decrementează \texttt{count\_value}, counter-ul intern se resetează și el la 0. Când \texttt{count\_value} ajunge la valoarea maximă/minimă și trebuie incrementat/decrementat conform counter-ului intern, el de fapt se întoarce la valoarea minimă/maximă.


\newpage


\section{PWM GENERATOR}

Se utilizează un bloc \texttt{always} activ pe frontul crescător al ceasului. La primirea semnalului de reset, valoarea lui \texttt{pwm\_out} se resetează la 0.\\
\\
Când \texttt{pwm\_en} este 0, \texttt{pwm\_out} este și el 0. Când \texttt{pwm\_en} este 1, se verifică în \texttt{functions} tipul de aliniere al semnalului, valoarea \texttt{count\_val} din momentul respectiv al ceasului și valoarea/valorile cu care aceasta din urmă trebuie comparată. În funcție de aceste condiții se determină semnalul \texttt{pwm\_out} la momentul dat.


\newpage



\end{document}